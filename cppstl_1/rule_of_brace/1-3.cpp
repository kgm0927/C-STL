//
// 
// 새로운 중괄호 초기화 규칙의 강점
// 
// 
// C++11에서 새로운 중괄호 초기화 구문인 {}가 추가되었다. 이는
// 집합체 초기화 뿐만 아니라 일반적으로 생성자 호출을 가능케 하는
// 목적을 뒀다. 하지만 auto 변수와 결합하면 잘못된 값을 사용하기 일쑤였다.
// 
// 이번 예제에서 C++17의 구문으로 변수를 초기화하는 올바른 방법을 명확히 알아보자.
// 
// 
// 
//			예제 구현
// 
// 변수는 한번에 초기화된다. 다음은 초기화 구문을 사용한 두 가지 상황이다.
// 
//		* auto 자료형의 추론 없이 중괄호 초기화 구문의 사용
// 
#include <iostream>
#include <vector>
using namespace std;


int x1 = 1;
int x2{ 1 };
int x3(1);

vector<int> v1{1, 2, 3};		// 1, 2, 3 세 개의 int 값을 갖는 vector
vector<int> v2 = { 1,2,3 };		// 이전과 동일함
vector<int> v3 (10, 20);		// 각 값이 20인 int 값 10개를 갖는 vector


//
// * auto 자료형의 추론으로 중괄호 초기화 구문의 사용
//

auto v{ 1 };	// v는 int이다.
// auto w {1,2} // 오류 : 단일 요소만 auto 초기화가 허용된다(새롭게 추가된 내용이다.).
auto x = { 1 }; // x는 std::initializer_list<int>
auto y = { 1,2 };	// y는 std::initializer_list<int>
// auto z = { 1,2,3.0 }; // 오류: 해당 자료형을 추론할 수 없다.	




//
//		예제 분석
// 
// std::vector나 std::list 같은 컨테이너를 초기화 할 때의 중괄호 초기화는 컨테이너 클래스의 std::initializer_list 생성자와
// 일치하게 된다. 이는 매우 탐욕스러운 방식으로 처리되는데, 즉 비집합체 생성자는 일치시키기가 불가능하다(비집합체 생성자는 일반적으로
// 초기화 목록이 허용되지 않는 생성자를 말한다).
// 
// 예를 들어 std::vector는 명확한 비집합체 생성자를 제공한다. std::vector<int> v (N,value)와 같이 임의의 동일한 값으로 많은 아이템을
// 채워 넣을 수 있다. std::vector<int> v {N,value}를 사용하면 initializer_list 생성자가 선택되는데, 이는 해당 벡터를 개수(N)와 값(value)
// 두 가지 요소로 초기화한다. 방심하면 실수하기 쉽다.
// 
// 일반적인 ()괄호로 호출하는 생성자와 비교했을 때 {} 연산의 매력적인 사실 중 하나는 암시적으로 자료형이 변환될 수 없다는 것이다.
// int x(1.2);과 int x=1.2는 x의 실수 값을 내림해 int로 변환해서 1의 값으로 초기화한다. 반면 int x{1,2}는 명시적으로 생성자
// 자료형과 일치해야 하므로 컴파일 될 수 없다.
// 
// 
// i 가장 좋은 초기화 방법이 무엇이냐는 질문에 대해서는 논란의 소지가 있다.
// 
// 중괄호 초기화 스타일을 선호호나느 개발자들은 중괄호를 사용하면 매우 명쾌하게 만들 수 있다고 한다.
// 즉, 변수는 생성자가 호출될 때만 초기화되며, 해당 코드는 또다시 초기화 되지 않는다는 것이다. 게다가
// ()괄호를 사용한 초기화는 가장 적절한 생성자를 찾아낼 뿐만 아니라 그 형 변환까지 처리하는 반면 {}
// 중괄호를 사용하면 올바른 생성자를 선택하는데 그치기 때문이다.
// 
// 
// C++11에서는 변수 auto x {123};의 자료형을 정확하게 맞추는 반면 C++17에서 소개된 추가적인 규칙은
// auto 자료형의 추론을 통한 초기화에 영향을 미친다. 하나의 요소를 갖는 std::initializer_list<int>는 원하는
// 대로 처리가 불가능하기 때문이다.
// 
// C++17은 다음과 같다.
//


//
//
// 
// auto var_name ={one_element}
// one_element와 같은 자료형이 되도록 var_name을 추론한다.
//
// 
// auto var_name {element1, element2, ...}; 유효하지 않으며 컴파일 되지 않는다.
// 
// auto var_name={element1, element2, ...}; 목록의 모든 요소가 같은 자료형이 되도록
// T로 std::initializer_list<T>를 추론한다.
// 
// 
// C++17은 실수로 초기화 목록을 정의하는 위험을 크게 줄였다.
//

